<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Giả Lập Mưa</title>
    <!-- Tải Tailwind CSS từ CDN để dễ dàng tạo kiểu -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Đặt kiểu cơ bản cho body */
        body {
            font-family: 'Inter', sans-serif; /* Sử dụng font Inter */
            overflow: hidden; /* Ẩn thanh cuộn nếu nội dung vượt quá kích thước màn hình */
            margin: 0;
            padding: 0;
            background-color: #0d1117; /* Màu nền tối để hiệu ứng mưa nổi bật */
        }
        /* Đặt kiểu cho canvas để nó phủ toàn bộ màn hình */
        canvas {
            position: fixed; /* Giữ canvas cố định trên màn hình */
            top: 0;
            left: 0;
            z-index: 1; /* Đặt canvas ở lớp dưới các điều khiển */
        }
        /* Đặt kiểu cho vùng điều khiển (buttons) */
        .controls {
            position: fixed; /* Giữ điều khiển cố định */
            bottom: 20px; /* Cách đáy 20px */
            left: 50%; /* Đặt giữa theo chiều ngang */
            transform: translateX(-50%); /* Dịch chuyển để căn giữa chính xác */
            z-index: 10; /* Đặt điều khiển ở lớp trên canvas */
            background-color: rgba(30, 41, 59, 0.8); /* Màu nền xanh đậm mờ (slate-800) */
            padding: 1.5rem; /* Đệm xung quanh */
            border-radius: 0.75rem; /* Bo tròn góc (rounded-xl) */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2); /* Thêm đổ bóng */
            display: flex; /* Sử dụng flexbox để sắp xếp các tùy chọn */
            gap: 1rem; /* Khoảng cách giữa các tùy chọn */
            flex-wrap: wrap; /* Cho phép các mục xuống dòng trên màn hình nhỏ */
            justify-content: center; /* Căn giữa các mục */
        }
        /* Đặt kiểu cho mỗi tùy chọn mưa (label chứa radio button) */
        .rain-option {
            display: flex; /* Sử dụng flexbox để căn chỉnh radio và văn bản */
            align-items: center; /* Căn chỉnh theo chiều dọc */
            background-color: rgba(55, 65, 81, 0.9); /* Màu nền xám mờ (gray-700) */
            padding: 0.75rem 1.25rem; /* Đệm */
            border-radius: 0.5rem; /* Bo tròn góc (rounded-lg) */
            cursor: pointer; /* Thay đổi con trỏ thành biểu tượng bàn tay */
            transition: background-color 0.2s ease, transform 0.1s ease; /* Hiệu ứng chuyển động mượt mà */
            color: #e2e8f0; /* Màu chữ (text-slate-200) */
            border: 2px solid transparent; /* Viền trong suốt mặc định */
        }
        /* Hiệu ứng khi di chuột qua tùy chọn */
        .rain-option:hover {
            background-color: rgba(75, 85, 99, 0.9); /* Màu xám đậm hơn khi hover */
            transform: translateY(-2px); /* Nhấc nhẹ lên */
        }
        /* Ẩn radio button mặc định và tạo kiểu riêng */
        .rain-option input[type="radio"] {
            margin-right: 0.75rem; /* Khoảng cách giữa radio và văn bản */
            appearance: none; /* Ẩn giao diện mặc định của radio button */
            width: 1.25rem;
            height: 1.25rem;
            border: 2px solid #94a3b8; /* Viền màu xanh xám (slate-400) */
            border-radius: 50%; /* Hình tròn */
            display: grid;
            place-content: center; /* Căn giữa nội dung bên trong */
            transition: border-color 0.2s ease; /* Hiệu ứng chuyển đổi màu viền */
        }
        /* Tạo dấu chấm bên trong radio button khi chưa chọn */
        .rain-option input[type="radio"]::before {
            content: '';
            width: 0.625rem;
            height: 0.625rem;
            border-radius: 50%;
            transform: scale(0); /* Ban đầu ẩn dấu chấm */
            transition: transform 0.2s ease; /* Hiệu ứng phóng to/thu nhỏ */
            box-shadow: inset 1em 1em #60a5fa; /* Màu xanh (blue-400) cho dấu chấm */
            background-color: CanvasText; /* Fallback cho màu nền */
        }
        /* Thay đổi màu viền khi radio button được chọn */
        .rain-option input[type="radio"]:checked {
            border-color: #60a5fa; /* Màu xanh (blue-400) */
        }
        /* Hiển thị dấu chấm khi radio button được chọn */
        .rain-option input[type="radio"]:checked::before {
            transform: scale(1); /* Phóng to dấu chấm */
        }
        /* Điều chỉnh responsive cho thiết bị di động */
        @media (max-width: 640px) {
            .controls {
                flex-direction: column; /* Xếp các tùy chọn theo cột */
                width: 90%; /* Chiếm 90% chiều rộng */
                left: 5%; /* Căn giữa bằng cách đặt left và transform */
                transform: translateX(0); /* Bỏ transform đã đặt trước đó */
                bottom: 10px; /* Cách đáy 10px */
                padding: 1rem; /* Đệm nhỏ hơn */
            }
            .rain-option {
                width: 100%; /* Mỗi tùy chọn chiếm toàn bộ chiều rộng */
                justify-content: center; /* Căn giữa nội dung trong tùy chọn */
            }
        }
    </style>
</head>
<body>
    <!-- Canvas sẽ là nơi vẽ hiệu ứng mưa -->
    <canvas id="rainCanvas"></canvas>

    <!-- Vùng chứa các tùy chọn cường độ mưa -->
    <div class="controls">
        <label class="rain-option">
            <input type="radio" name="rainIntensity" value="light" checked>
            Mưa Nhỏ
        </label>
        <label class="rain-option">
            <input type="radio" name="rainIntensity" value="medium">
            Mưa Vừa
        </label>
        <label class="rain-option">
            <input type="radio" name="rainIntensity" value="heavy">
            Mưa To
        </label>
    </div>

    <!-- Phần tử audio để phát âm thanh mưa. "loop" để lặp lại âm thanh -->
    <audio id="rainSound" loop></audio>

    <script>
        // Get necessary DOM elements from HTML
        const canvas = document.getElementById('rainCanvas');
        const ctx = canvas.getContext('2d'); // Get 2D context for drawing
        const rainSound = document.getElementById('rainSound');
        const rainOptions = document.querySelectorAll('input[name="rainIntensity"]');

        let raindrops = []; // Array to hold all raindrops
        let numDrops = 100; // Default number of raindrops (light rain)
        let dropSpeed = 10; // Default drop speed
        let dropLength = 15; // Default drop length
        let dropOpacity = 0.6; // Default drop opacity
        let soundVolume = 0.5; // Default sound volume
        let windSpeed = 0; // Wind speed, makes raindrops tilt horizontally

        // Variables for lightning effect
        let isLightning = false; // Lightning active state
        let lastLightningTime = 0; // Last lightning strike time
        let lightningIntervalMin = 5000; // Minimum interval between lightning strikes (5 seconds)
        let lightningIntervalMax = 15000; // Maximum interval between lightning strikes (15 seconds)
        let nextLightningTime = 0; // Next lightning strike time
        let lightningDuration = 100; // Duration lightning is visible (milliseconds)

        // --- NEW: Audio sources for each rain intensity ---
        // IMPORTANT: Please replace these links with your actual MP3 rain sound links.
        // You can find royalty-free rain sound MP3s on websites like FreeSound.org or other sound libraries.
        const audioSources = {
            light: 'https://cdn.pixabay.com/audio/2024/01/25/audio_b05a8ceddc.mp3', // Placeholder for light rain sound
            medium: 'https://cdn.pixabay.com/audio/2025/02/07/audio_84e92d6021.mp3', // Placeholder for medium rain sound
            heavy: 'https://cdn.pixabay.com/audio/2024/08/20/audio_e79013ed4c.mp3'  // Placeholder for heavy rain sound (previously used general sound)
        };
        // --- END NEW ---

        rainSound.volume = soundVolume; // Set initial volume

        // Function to resize the canvas to always match the browser window size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Re-initialize raindrops when canvas size changes to distribute them evenly
            initRaindrops();
        }

        // Function to initialize and populate the 'raindrops' array
        function initRaindrops() {
            raindrops = []; // Clear old raindrops
            for (let i = 0; i < numDrops; i++) {
                raindrops.push({
                    x: Math.random() * canvas.width, // Random X position within canvas
                    y: Math.random() * canvas.height, // Random Y position within canvas
                    length: dropLength + Math.random() * 5, // Add small variation to length
                    speed: dropSpeed + Math.random() * 2, // Add small variation to speed
                    opacity: dropOpacity + Math.random() * 0.2 // Add small variation to opacity
                });
            }
        }

        // Function to draw a raindrop on the canvas, considering wind
        function drawRaindrop(drop) {
            ctx.beginPath(); // Start a new path
            ctx.moveTo(drop.x, drop.y); // Move to the starting point of the raindrop

            // Calculate the end point of the raindrop based on wind speed and drop length
            // drop.windOffset will make the raindrop tilt in the direction of the wind
            const windOffset = windSpeed * (drop.length / drop.speed);
            ctx.lineTo(drop.x + windOffset, drop.y + drop.length); // Draw a tilted line to form the raindrop

            ctx.lineWidth = 1; // Line width
            ctx.strokeStyle = `rgba(173, 216, 230, ${drop.opacity})`; // Light blue color with opacity
            ctx.stroke(); // Draw the line
        }

        // Function to update the position of all raindrops
        function updateRaindrops() {
            for (let i = 0; i < raindrops.length; i++) {
                const drop = raindrops[i];
                drop.y += drop.speed; // Move raindrop downwards by speed
                drop.x += windSpeed; // Move raindrop horizontally by wind speed

                // If raindrop falls off screen (including horizontally due to wind), bring it back to the top of the canvas
                // Include an offset for the drop length to ensure it's completely off screen
                if (drop.y > canvas.height || drop.x > canvas.width + drop.length || drop.x < -drop.length) {
                    drop.y = -drop.length; // Start from above the screen
                    drop.x = Math.random() * canvas.width; // New random X position for natural appearance
                    // Ensure raindrop doesn't appear too far off-screen due to strong wind
                    if (windSpeed > 0 && drop.x < -windSpeed * 10) drop.x += canvas.width;
                    if (windSpeed < 0 && drop.x > canvas.width - windSpeed * 10) drop.x -= canvas.width;
                }
            }
        }

        // Function to handle lightning effect
        function handleLightning() {
            const currentTime = Date.now(); // Get current time
            if (!isLightning && currentTime > nextLightningTime) {
                // 10% chance for lightning to strike
                if (Math.random() < 0.1) {
                    isLightning = true;
                    // Set canvas background color to bright white to simulate lightning flash
                    canvas.style.backgroundColor = `rgba(255, 255, 255, ${Math.random() * 0.3 + 0.3})`; // Random brightness
                    // Set next lightning strike time
                    nextLightningTime = currentTime + lightningIntervalMin + Math.random() * (lightningIntervalMax - lightningIntervalMin);

                    // Turn off lightning after a short duration
                    setTimeout(() => {
                        isLightning = false;
                        canvas.style.backgroundColor = '#0d1117'; // Return to original background color
                    }, lightningDuration);
                }
            }
        }

        // Main animation loop, continuously draws and updates raindrops
        function animate() {
            // Clear entire canvas to draw new frame. If lightning is active, don't clear for brighter effect.
            if (!isLightning) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            handleLightning(); // Handle lightning effect

            updateRaindrops(); // Update position of all raindrops
            for (let i = 0; i < raindrops.length; i++) {
                drawRaindrop(raindrops[i]); // Draw each raindrop
            }
            requestAnimationFrame(animate); // Request browser to call animate() in the next frame
        }

        // Function to update rain intensity based on user selection
        function updateRainIntensity(intensity) {
            // --- NEW: Set audio source based on intensity ---
            rainSound.src = audioSources[intensity];
            // --- END NEW ---

            switch (intensity) {
                case 'light': // Light rain
                    numDrops = 100;
                    dropSpeed = 8;
                    dropLength = 12;
                    dropOpacity = 0.5;
                    soundVolume = 0.3;
                    windSpeed = 0; // No wind
                    lightningIntervalMin = 15000; // Less frequent lightning
                    lightningIntervalMax = 30000;
                    break;
                case 'medium': // Medium rain
                    numDrops = 300;
                    dropSpeed = 12;
                    dropLength = 18;
                    dropOpacity = 0.7;
                    soundVolume = 0.6;
                    windSpeed = 2; // Light wind
                    lightningIntervalMin = 8000; // Moderate lightning
                    lightningIntervalMax = 20000;
                    break;
                case 'heavy': // Heavy rain
                    numDrops = 700;
                    dropSpeed = 18;
                    dropLength = 25;
                    dropOpacity = 0.9;
                    soundVolume = 1.0;
                    windSpeed = 5; // Stronger wind
                    lightningIntervalMin = 3000; // More frequent lightning
                    lightningIntervalMax = 10000;
                    break;
            }
            initRaindrops(); // Re-initialize raindrop count and properties
            rainSound.volume = soundVolume; // Adjust volume
            // Play sound if it's paused
            if (rainSound.paused) {
                // Use .catch() to handle errors if browser blocks autoplay
                rainSound.play().catch(e => console.error("Error playing audio:", e));
            }
            // Reset next lightning time when rain intensity changes
            nextLightningTime = Date.now() + lightningIntervalMin + Math.random() * (lightningIntervalMax - lightningIntervalMin);
        }

        // Listen for "change" event on rain intensity radio buttons
        rainOptions.forEach(option => {
            option.addEventListener('change', (event) => {
                updateRainIntensity(event.target.value); // Call function to update rain intensity
            });
        });

        // Handle event when entire page is loaded
        window.addEventListener('load', () => {
            resizeCanvas(); // Set initial canvas size
            // Get the value of the initially selected radio button and update rain intensity
            updateRainIntensity(document.querySelector('input[name="rainIntensity"]:checked').value);
            animate(); // Start animation loop
        });
        // Listen for "resize" event of the window to adjust canvas when size changes
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
